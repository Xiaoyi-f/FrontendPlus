一、正则机器人的 “基础词汇”（核心组成部分）
正则机器人的语言很简单，核心就这几类 “词汇”，掌握了它们，就相当于学会了正则的基础骨架。
1. 普通字符：机器人认识的 “普通字”
就是咱们平时用的字母（a-z、A-Z）、数字（0-9）、汉字（张三李四），还有普通符号（@、-、_）。这些字符没啥特殊能力，机器人看到它们，就只会 “找一模一样的”。
比如你让机器人找 “张三”，它就只会在字符串里挑出 “张三” 这两个字，不会找 “李四”，也不会找 “张小三”，就是精准匹配自身。
2. 元字符：机器人的 “特殊技能道具”
这是正则的灵魂，相当于机器人的 “超能力”，能帮它完成复杂的查找任务。咱们分两类来讲，都是最常用的，不用记复杂的：
（1）基础 “超能力道具”（必掌握）
.：万能匹配道具，能匹配除了 “换行符”（就是咱们打字时按回车换的那一行）之外的任何一个字符。比如 “a.b”，可以匹配 “a1b”“aab”“a@b”，只要中间是一个字符，就能对上。
^：开头定位道具，告诉机器人 “只从字符串的最开头开始找”。比如 “^ 张三”，只有字符串一开头就是 “张三”，才算匹配成功，像 “李四张三” 就不行。
$：结尾定位道具，告诉机器人 “只找字符串的最后结尾部分”。比如 “张三 $”，只有字符串最后两个字是 “张三” 才算数，像 “张三李四” 就不行。
*：无限重复道具（0 次及以上），让它前面的那个字符 “想出现多少次就出现多少次，也可以不出现”。比如 “a*”，可以匹配 “”（空的）、“a”、“aa”、“aaa”…… 一直到无数个 a。
+：最少一次道具（1 次及以上），和*类似，但要求前面的字符 “至少出现 1 次，不能不出现”。比如 “a+”，可以匹配 “a”、“aa”、“aaa”…… 但不能匹配空的。
?：可选道具（0 次或 1 次），让前面的字符 “要么出现 1 次，要么不出现，就这两种情况”。比如 “a?”，只能匹配 “”（空的）或者 “a”，不能匹配 “aa”。
[]：字符集合道具，告诉机器人 “只要匹配这个集合里的任意一个字符就行”。比如 “[abc]”，只要字符是 a、b、c 中的一个，就算匹配成功；再比如 “[0-9]”，就是 0 到 9 的任意一个数字。
[^]：反向字符集合道具，和[]相反，告诉机器人 “匹配不在这个集合里的任意一个字符”。比如 “[^abc]”，只要不是 a、b、c 的字符，都能匹配。
()：分组打包道具，把一堆字符 “打包成一个整体”，方便后续操作。比如 “(ab)+”，就是把 “ab” 看成一个整体，能匹配 “ab”、“abab”、“ababab”…… 如果没有括号，“ab+” 就是 a 后面跟任意多个 b 了。
|：或者选择道具，告诉机器人 “匹配左边的内容，或者右边的内容都行”。比如 “张三 | 李四”，只要字符串里有 “张三” 或者 “李四”，都能匹配到。
\：转义道具，专门 “解除” 其他元字符的超能力。比如.是万能匹配道具，如果你想让机器人真的找 “.” 这个点，不是万能匹配，就需要在前面加\，写成 “.”，这样机器人就知道 “我要找的是一个实实在在的点”。再比如想找 “*”，就要写成 “*”。
（2）扩展 “超能力道具”（懒人必备，简化操作）
这些道具其实是 “基础道具” 的简化版，不用自己拼复杂的集合，直接用就行：
\d：数字道具，等价于 “[0-9]”，专门找 0 到 9 的任意一个数字，不用手动写 “[0-9]” 了。
\D：非数字道具，等价于 “[^0-9]”，专门找不是数字的字符。
\w：常用字符道具，等价于 “[a-zA-Z0-9_]”，专门找字母（大小写）、数字、下划线，这些是平时命名、账号里最常用的字符。
\W：非常用字符道具，等价于 “[^a-zA-Z0-9_]”，找不是字母、数字、下划线的字符，比如 @、#、￥这些符号。
\s：空白字符道具，专门找空格、制表符（按 Tab 键的那个空格）、换行符这些 “看不见的空白”。
\S：非空白字符道具，找不是空白的所有字符。
\b：单词边界道具，找 “单词和非单词之间的分界线”。比如你想找 “cat” 这个单词，不想找 “category” 里的 “cat”，就可以用 “\bcat\b”，机器人就知道 “我要找的是独立的 cat 单词，不是单词里的片段”。
\B：非单词边界道具，和\b相反，找的是 “单词内部的位置”。
3. 量词：机器人的 “数量指令”
就是告诉机器人 “某个字符或分组要出现多少次”，分两种，都很简单：
（1）精确量词：指定固定次数
{n}：告诉机器人 “必须恰好出现 n 次”。比如 “\d {3}”，就是必须是 3 个数字，多一个少一个都不行，像 “123” 可以，“12” 或 “1234” 就不行。
（2）模糊量词：指定范围次数
其实就是咱们前面说的*、+、?的另一种写法，同时还有更灵活的范围：
*：等价于{0,}，就是 “0 次或无限次，随便来”。
+：等价于{1,}，就是 “1 次或无限次，至少来一次”。
?：等价于{0,1}，就是 “0 次或 1 次，可有可无”。
{n,}：“至少出现 n 次，多了不限”。比如 “\d {8,}”，就是数字至少 8 个，8 个、9 个、100 个都可以。
{n,m}：“至少出现 n 次，最多出现 m 次”。比如 “\d {6,18}”，就是数字最少 6 个，最多 18 个，在这个范围内都行。
另外，?还有一个额外功能：“取消贪婪”。啥叫贪婪？就是机器人默认会 “尽可能多的匹配内容”。比如字符串 “a1b2b3”，你用 “a.b” 去匹配，机器人会贪婪地匹配到 “a1b2b”（一直到最后一个 b）；但如果你加个?，写成 “a.?b”，机器人就会 “见好就收”，只匹配到 “a1b”（最短的符合条件的内容），这就是非贪婪匹配，平时精准提取内容的时候特别有用。
4. 修饰符：机器人的 “行为调整开关”
这些开关不参与具体的字符串匹配，只是调整机器人的工作方式，常用的就这几个：
i：忽略大小写开关，打开这个开关后，机器人匹配字母时，不管是大写还是小写，都算一样的。比如 “a” 可以匹配 “A”，“B” 可以匹配 “b”，不用再写 “[aA]”、“[bB]” 了。
g：全局匹配开关，默认机器人只找第一个符合条件的内容，打开这个开关后，会把字符串里所有符合条件的内容都找出来。比如字符串 “123abc456def”，用 “\d+” 默认只找到 “123”，打开g开关后，会找到 “123” 和 “456” 两个。
m：多行匹配开关，默认情况下，^和$只认整个字符串的开头和结尾，打开这个开关后，^和$会认每一行的开头和结尾。比如字符串 “张三 \n 李四”（\n 是换行符），用 “^ 李四” 默认匹配不到，打开m开关后，就能匹配到第二行开头的 “李四” 了。
s：万能匹配开关，默认情况下，.不能匹配换行符，打开这个开关后，.就能匹配包括换行符在内的所有字符了。如果你的语言不支持s开关（比如早期的 JS），可以用 “[\s\S]” 来代替.，效果一样，能匹配所有字符。
u：Unicode 支持开关，打开这个开关后，机器人就能正确识别中文、表情这些 Unicode 字符了，比如用 “\p {Han}” 就能匹配中文（不用再写复杂的字符集）。
x：忽略空格开关，打开这个开关后，正则表达式里的空格和注释会被忽略，方便你写复杂正则时换行、加注释，让正则更易读。
5. 进阶组件：机器人的 “高级技能”
这些技能是用来处理复杂场景的，学会了之后，你的正则水平就直接上一个台阶，达到大厂架构师级别了。
（1）分组：机器人的 “打包与分类”
就是前面说的()，主要分 3 种，各自有不同用途：
捕获组：普通的()，比如 “(\d {3})(\d {4})”，机器人会把每个括号里匹配到的内容 “记下来”，后面可以引用这些内容。比如第一个括号匹配到 “138”，第二个匹配到 “0013”，后面就能把这两个内容调出来用。
非捕获组：(?:)，和捕获组的区别是，机器人只会把它当成一个整体匹配，但不会 “记下来”，后面不能引用。比如 “(?:\d {3}.){3}”，就是把 “3 个数字 + 一个点” 当成整体，重复 3 次，但机器人不会记录每个括号里的内容，适合不需要引用的整体匹配，效率更高。
命名捕获组：(?<name>...)，给捕获组起个名字，比如 “(?<phone1>\d{3})(?<phone2>\d {4})”，第一个分组叫 “phone1”，第二个叫 “phone2”，后面引用的时候可以用名字来调用，不用记顺序，复杂正则里特别方便，不容易搞混。
（2）零宽断言：机器人的 “隔空检查”
你可以把它理解成机器人的 “透视眼”，它只 “检查” 某个位置前面或后面有没有符合条件的内容，不会 “消耗” 字符串（也就是不会占用字符位置，检查完之后还会回到原来的位置），就像一个 “隐形的检查官”。常用的有 4 种：
正向先行断言：(?=...)，“检查当前位置后面有没有符合... 的内容”。比如 “密码必须包含数字”，就可以用 “(?=.*\d)”，机器人会站在字符串开头，往后看有没有数字，不管数字在开头、中间还是结尾，只要有就通过检查，而且检查完还会回到开头，不影响后面的检查。
正向先行否定断言：(?!...)，和上面相反，“检查当前位置后面有没有不符合... 的内容”，如果有就匹配失败。比如 “密码不能包含空格”，就可以用 “(?!.*\s)”，只要后面有空格，就不符合要求。
正向后行断言：(?<=...)，“检查当前位置前面有没有符合... 的内容”。比如 “想提取‘￥’后面的数字”，就可以用 “(?<=￥)\d+”，机器人会先检查前面有没有 “￥”，有就提取后面的数字。
正向后行否定断言：(?<!...)，和上面相反，“检查当前位置前面有没有不符合... 的内容”，如果有就匹配失败。比如 “想提取不是‘￥’后面的数字”，就可以用 “(?<!￥)\d+”。
（3）反向引用：机器人的 “回忆功能”
就是机器人把前面捕获组 “记下来” 的内容，后面再调出来用，分两种场景：
正则内部引用：用\n（n 是数字，1 代表第一个捕获组，2 代表第二个，以此类推）。比如 “想匹配重复的两个字符，像‘aa’、‘bb’、‘11’”，就可以用 “(\w)\1”，第一个(\w)捕获一个字符，\1就引用这个字符，确保后面的字符和前面一样。
正则外部引用：在替换字符串的时候用，JS 里用$n，Python 里用\n。比如把手机号 “13800138000” 改成 “138-0013-8000”，就可以先用 “(\d {3})(\d {4})(\d {4})” 捕获三个分组，然后替换成 “$1-$2-$3”，机器人就会把三个分组的内容填进去，完成格式化。
二、正则机器人的 “四大工作场景”（覆盖所有实际需求）
学会了正则的 “语言规则”，接下来咱们看看这个机器人能帮咱们做哪些实际工作，这四大场景涵盖了所有开发中的需求，掌握了就够用了。
1. 场景一：匹配验证（判断 “格式对不对”）
这是最常用的场景，比如用户注册时，验证手机号、邮箱、密码是不是符合格式要求，本质就是 “判断整个字符串是不是完全符合咱们设定的规则”。
举几个实际例子，都是工作中常用的：
手机号验证：^1[3-9]\d{9}$
解释：^开头，必须是 1 开头；[3-9]第二个数字是 3 到 9 中的一个；\d{9}后面跟 9 个数字；$结尾，确保整个字符串就是 11 位手机号，没有多余的字符。
邮箱验证：^[a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$
解释：^开头；前面是字母、数字、点、下划线、百分号、减号，至少一个；然后是 @符号；接着是邮箱域名的前缀（字母、数字、点、减号）；然后是一个实实在在的点（.）；最后是域名后缀（2 到 6 个字母，比如 com、cn、net）；$结尾，确保格式正确。
密码强度验证（至少 8 位，包含大小写字母和数字）：(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,}
解释：前面三个都是正向先行断言，分别检查有没有数字、小写字母、大写字母，检查完都回到开头；最后.{8,}确保密码至少 8 位，整体就是符合强度要求的密码。
2. 场景二：文本提取（从字符串里 “挑出想要的内容”）
就是从一大段文本里，把符合规则的内容 “抠出来”，比如提取所有手机号、提取 HTML 里的图片地址、提取日志里的错误信息。
举个例子：从 “姓名：李四，手机号：13800138000，邮箱：lisi_123@test.com” 里提取姓名、手机号、邮箱。正则可以写成：姓名：(.*?)，手机号：(.*?)，邮箱：(.*?)，解释：用(.*?)非贪婪匹配，分别捕获姓名、手机号、邮箱的内容，机器人会把这些内容记下来，咱们后面直接用就行，不用手动去截取字符串。
再比如提取所有 IP 地址：\b(?:\d{1,3}\.){3}\d{1,3}\b解释：\b确保是独立的 IP 地址；(?:\d{1,3}\.){3}是 “1 到 3 个数字 + 一个点” 重复 3 次；最后跟 “1 到 3 个数字”；\b结尾，这样就能准确提取出所有 IP 地址了。
3. 场景三：字符串替换（把内容 “改成想要的格式”）
就是把符合规则的字符串，替换成咱们需要的格式，比如手机号脱敏、格式化手机号、过滤 HTML 标签。
举几个例子：
手机号格式化（13800138000 → 138-0013-8000）：
正则：(\d{3})(\d{4})(\d{4})，替换为：$1-$2-$3
解释：三个捕获组分别捕获前 3 位、中间 4 位、后 4 位，替换时用$1、$2、$3引用这三个内容，加上横杠就完成格式化。
身份证脱敏（440101199001011234 → 440101********1234）：
正则：(\d{6})(\d{8})([\dXx]{4})，替换为：$1********$3
解释：捕获前 6 位、中间 8 位、后 4 位，替换时保留前 6 位和后 4 位，中间用 8 个星号代替，完成脱敏。
过滤 HTML 标签（把<div>张三</div>变成 “张三”）：
正则：<[^>]+>，替换为：空字符串
解释：<匹配标签开头，[^>]匹配不是>的任意字符，+确保至少一个，>匹配标签结尾，这样就能匹配所有 HTML 标签，替换成空字符串就过滤掉了。
4. 场景四：字符串分割（把字符串 “拆分成数组”）
就是按指定的规则，把一个字符串拆分成多个部分，存到数组里，比如按逗号或分号分割、按空格分割。
举个例子：把 “张三，李四；王五 赵六” 拆分成每个人的名字。正则可以写成：\s*[,;]\s*解释：\s*匹配任意个空白字符（包括空格），[,;]匹配逗号或分号，这样不管是 “,”、“;”，还是前后有空格，都能作为分割符，拆分后得到 ["张三", "李四", "王五 赵六"]，后续再处理即可。
再比如按非单词字符分割（把 “hello-world_123!python” 拆分成单词）：正则：\W+解释：\W+匹配任意多个非单词字符（-、! 这些），分割后得到 ["hello", "world_123", "python"]。
三、新手必看：正则机器人的 “使用技巧与避坑指南”
很多小白用正则的时候容易踩坑，记住这几点，能让你少走 99% 的弯路：
1. 贪婪与非贪婪：精准匹配用 “非贪婪”
默认机器人是 “贪婪的”，会尽可能多匹配内容，如果你想精准提取最短的符合条件的内容，就在量词后面加?，切换成非贪婪模式。比如想提取 “a1b2b3” 里的 “a1b”，就用 “a.*?b”，而不是 “a.*b”。
2. 转义处理：元字符要 “脱帽”
如果想匹配元字符本身（比如.、*、+、(、)这些），一定要在前面加\，让它失去超能力，变成普通字符。比如想匹配 “www.baidu.com” 里的点，就要写成 “.”，不能直接写 “.”；想匹配文件路径 “C:\Users\ 张三” 里的反斜杠，就要写成 “\”（因为反斜杠本身也是转义字符，需要转义自己）。
3. 换行处理：匹配换行用 “s 开关” 或 “[\s\S]”
默认情况下，.不能匹配换行符，如果你的文本里有换行，想匹配所有内容，就加s修饰符；如果你的语言不支持s开关（比如 JS），就用 “[\s\S]” 代替.，它能匹配所有空白和非空白字符，也就是包括换行符在内的所有字符。
4. 中文匹配：用 “[\u4e00-\u9fa5]” 准没错
如果想匹配中文，最兼容所有编程语言的写法是 “[\u4e00-\u9fa5]”，这是中文的 Unicode 编码范围，不管是 JS、Python 还是 Java，都能用；如果你的语言支持u修饰符（比如 JS、Python3），也可以用 “\p {Han}”，更简洁。
5. 边界控制：避免 “部分匹配”
如果想验证整个字符串的格式（比如手机号、邮箱），一定要用^和$限定首尾，不然机器人会匹配到部分符合条件的内容。比如用 “1 [3-9]\d {9}” 验证 “13800138000abc”，会匹配到 “13800138000”，误以为格式正确，加上^和$之后，就会发现整个字符串不符合，避免错误。
如果想匹配独立的单词，就用\b限定单词边界，比如想找 “cat”，不用 “cat”，而用 “\bcat\b”，避免匹配到 “category” 里的 “cat”

