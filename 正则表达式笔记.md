# 正则表达式核心知识点终极总结
正则表达式是一套用于**匹配、查找、替换、分割字符串**的强大模式语言，掌握以下核心内容即可应对99%的实际开发场景：

## 一、核心组成部分（正则的基础骨架）
1.  **普通字符**：字母、数字、汉字、普通符号（如`@`、`-`），直接匹配自身，无特殊含义。
2.  **元字符**：正则的灵魂，分为基础元字符和扩展元字符，核心如下：
    - 基础元字符：`.`（任意非换行字符）、`^`（字符串/行开头）、`$`（字符串/行结尾）、`*`（0次及以上）、`+`（1次及以上）、`?`（0次或1次）、`[]`（字符集）、`[^]`（否定字符集）、`()`（分组）、`|`（或运算）、`\`（转义符）
    - 扩展元字符：`\d`（数字）、`\D`（非数字）、`\w`（字母/数字/下划线）、`\W`（非字母/数字/下划线）、`\s`（空白字符）、`\S`（非空白字符）、`\b`（单词边界）、`\B`（非单词边界）
3.  **量词**：指定匹配次数，分为精确量词和模糊量词：
    - 精确量词：`{n}`（恰好n次）
    - 模糊量词：`*`（等价`{0,}`）、`+`（等价`{1,}`）、`?`（等价`{0,1}`），`?`还可用于取消贪婪匹配（`*?`、`+?`）
4.  **修饰符**：调整匹配行为，不参与具体匹配，核心修饰符：
    - `i`：忽略大小写；`g`：全局匹配；`m`：多行匹配；`s`：让`.`匹配换行符；`u`：支持Unicode（中文/表情）；`x`：忽略正则内空格和注释
5.  **进阶组件**：
    - 分组：捕获组`()`（可引用）、非捕获组`(?:)`（仅整体匹配，不捕获）、命名捕获组`(?<name>...)`（便于复杂正则引用）
    - 零宽断言：正向先行`(?=...)`、正向先行否定`(?!...)`、正向后行`(?<=...)`、正向后行否定`(?<!...)`（匹配位置，不消耗字符）
    - 反向引用：正则内`\n`、正则外`$n`（JS）/`\n`（Python），引用捕获组内容

## 二、核心用途（四大核心场景，覆盖所有需求）
1.  **匹配验证**：判断字符串是否符合指定格式（如手机号`^1[3-9]\d{9}$`、邮箱`^[a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$`、密码强度验证）
2.  **文本提取**：从字符串中获取符合规则的子串（如提取所有IP地址`\b(?:\d{1,3}\.){3}\d{1,3}\b`、HTML图片地址、日志错误信息）
3.  **字符串替换**：将符合规则的子串替换为目标格式（如手机号格式化`(\d{3})(\d{4})(\d{4})`替换为`$1-$2-$3`、过滤HTML标签`<[^>]+>`、空格替换为逗号）
4.  **字符串分割**：按指定规则拆分字符串为数组（如按逗号/分号分割`\s*[,;]\s*`、按非单词字符分割`\W+`）

## 三、关键技巧与避坑指南（新手必看）
1.  **贪婪与非贪婪**：默认贪婪匹配（尽可能多匹配），需精准匹配时在量词后加`?`切换为非贪婪（如`a.*?b`匹配最短符合条件的子串）
2.  **转义处理**：元字符（`.`、`*`、`+`等）需用`\`转义才能匹配自身（如匹配`.`需写`\.`，匹配文件路径需转义`\`）
3.  **换行处理**：默认`.`不匹配换行，需匹配含换行文本时加`s`修饰符（JS兼容用`[\s\S]`替代`.`）
4.  **中文匹配**：用`[\u4e00-\u9fa5]`（兼容所有语言）或`\p{Han}`+`u`修饰符（JS/Python3）匹配中文
5.  **边界控制**：用`^`和`$`限定字符串首尾，避免部分匹配；用`\b`匹配单词边界，避免匹配单词片段
6.  **工具辅助**：复杂正则用Regex101、Regexr等在线工具调试，提高效率；复杂结构化数据（JSON/XML）优先用专用解析库，不依赖正则

## 四、核心总结
正则表达式的核心是「用简洁的模式描述一组字符串规则」，掌握「普通字符+元字符+量词+修饰符」的基础用法，结合「分组/断言/反向引用」的进阶技巧，就能应对表单验证、文本处理、日志分析等所有实际场景。无需额外深入学习，遇到具体问题只需通过在线工具调试优化即可，核心知识点已全覆盖

## 五、小示例：
示例：(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,}
讲解：
咱们把这个正则拆成 4 段，一段一段讲，就像拼积木一样：(?=.*\d) + (?=.*[a-z]) + (?=.*[A-Z]) + .{8,}
第一段：(?=.*\d) → 要求密码里必须有数字
咱们拆成小部分看：
(?=...)：可以理解为「检查官」，它不占密码的位置，就负责站在密码开头，往后看有没有符合要求的内容，看完之后还会回到开头，不影响后面的检查；
.*：「万能通行证」，可以匹配密码里任意多的字符（比如字母、符号），也可以没有字符，作用是 “跳过前面的所有内容”，不管数字在密码的开头、中间还是结尾，都能找到；
\d：「数字代表」，就是指 0-9 中的任意一个数字
合起来意思：密码里必须至少有一个数字，不管数字在哪个位置都算
第二段：(?=.*[a-z]) → 要求密码里必须有小写字母
还是(?=...)这个「检查官」，继续回到密码开头检查；
.*：还是「万能通行证」，跳过小写字母前面的任意内容；
[a-z]：「小写字母代表」，就是指 a、b、c 一直到 z 的任意一个小写字母
合起来意思：密码里必须至少有一个小写字母，位置随便放
第三段：(?=.*[A-Z]) → 要求密码里必须有大写字母
依旧是(?=...)「检查官」，再回到密码开头检查；
.*：「万能通行证」，跳过大写字母前面的任意内容；
[A-Z]：「大写字母代表」，就是指 A、B、C 一直到 Z 的任意一个大写字母
合起来意思：密码里必须至少有一个大写字母，放在哪都可以。
第四段：.{8,} → 要求密码长度至少 8 位
.：「任意字符代表」，可以匹配密码里的任何一个字符（数字、字母、符号都算，除了换行）；
{8,}：「长度要求」，{n,}就是指 “至少 n 个”，这里就是 “至少 8 个”，意思是密码的总字符数不能少于 8 个

## 六、大示例
// 1. 原始用户信息字符串
const userStr = "姓名：李四，手机号：13800138000，邮箱：lisi_123@test.com，身份证：440101199001011234，密码：LiSi@1234";

// 2. 定义核心正则（涵盖元字符、量词、分组、断言等核心语法）
const regs = {
  // 手机号验证：^开头、$结尾、\d数字、{9}精确量词
  phoneCheck: /^1[3-9]\d{9}$/,
  // 邮箱验证：字符集、@、转义符\.、{2,6}范围量词
  emailCheck: /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/,
  // 提取核心信息：捕获组(.*?)非贪婪匹配，匹配姓名、手机号、邮箱
  extractInfo: /姓名：(.*?)，手机号：(.*?)，邮箱：(.*?)，/,
  // 手机号格式化：捕获3个分组，用于反向引用
  phoneFormat: /(\d{3})(\d{4})(\d{4})/,
  // 身份证脱敏：捕获前6位、中间8位、后4位，隐藏中间部分
  idCardHide: /(\d{6})(\d{8})([\dXx]{4})/
};

// 3. 步骤1：提取核心信息
const extractResult = userStr.match(regs.extractInfo);
const [, name, phone, email] = extractResult; // 解构捕获组内容

// 4. 步骤2：验证手机号和邮箱格式
const isPhoneValid = regs.phoneCheck.test(phone);
const isEmailValid = regs.emailCheck.test(email);

// 5. 步骤3：格式化处理
const formattedPhone = phone.replace(regs.phoneFormat, "$1-$2-$3"); // 反向引用替换
const idCard = userStr.match(/身份证：(.*?)，/)[1]; // 提取身份证
const hiddenIdCard = idCard.replace(regs.idCardHide, "$1********$3"); // 身份证脱敏

// 6. 打印最终结果
console.log("=== 极简正则综合示例结果 ===");
console.log("原始姓名：", name);
console.log("原始手机号：", phone, "→ 格式化手机号：", formattedPhone, "→ 格式是否有效：", isPhoneValid);
console.log("原始邮箱：", email, "→ 格式是否有效：", isEmailValid);
console.log("原始身份证：", idCard, "→ 脱敏身份证：", hiddenIdCard);


